// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

//

// takes all the prisma code and convert it
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

/**
 * ===== Enums =====
 */

enum TournamentStatus {
  NOT_STARTED
  ONGOING
  FINISHED
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum MatchResult {
  WIN
  LOSS
}

/**
 * ===== Core User =====
 */

model User {
  id                Int      @id @default(autoincrement())
  username          String   @unique
  email             String   @unique
  passwordHash      String
  twoFactorSecret   String?
  isTwoFactorEnabled Boolean  @default(false)
  backupCodes       String? // Add this line
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // back-relations
  wonTournaments       Tournament[]       @relation("tournamentsWon")
  requestsRequested Friendship[]       @relation("requested")
  requestsReceived  Friendship[]       @relation("received")
  matchPlayers         MatchPlayer[]
  TournamentPlayer     TournamentPlayer[]

  // @@index([email])

  Tournament Tournament[] @relation("tournamentsCreated")
}

/**
 * ===== Friendships (edge table) =====
 */

model Friendship {
  // id        Int              @id @default(autoincrement())
  requesterId Int
  addresseeId Int
  status    FriendshipStatus @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  
  requesterUser User @relation("requested", fields: [requesterId], references: [id], onDelete: Cascade)
  addresseeUser User @relation("received", fields: [addresseeId], references: [id], onDelete: Cascade)

  @@id([requesterId, addresseeId])
  @@index([addresseeId, status]) // “incoming pending requests”
}

/**
 * ===== Tournaments =====
 */

model Tournament {
  id     Int              @id @default(autoincrement())
  name   String
  status TournamentStatus @default(NOT_STARTED)

  creatorId Int?

  winnerId Int?

  // Back-relation to matches via Match.tournament
  matches Match[]

  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  TournamentPlayer TournamentPlayer[]

  // Back-relations
  winner   User? @relation("tournamentsWon", fields: [winnerId], references: [id], onDelete: SetNull)
  creator   User? @relation("tournamentsCreated", fields: [creatorId], references: [id], onDelete: SetNull)

  // @@index([status])
  // @@index([creatorId])
  // @@index([winnerId])
}

/**
 * ===== Preregistration / membership =====
 */

model TournamentPlayer {
  tournamentId Int
  userId       Int
  joinedAt     DateTime @default(now())

  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  // If aliases must be unique within a tournament:
  // @@unique([tournamentId, displayName])

  @@id([tournamentId, userId])
  @@index([userId])
}

/**
 * ===== Matches =====
 */

model Match {
  id           Int       @id @default(autoincrement())
  tournamentId Int? // null => casual match
  startedAt    DateTime  @default(now())
  finishedAt   DateTime?

  tournament Tournament?   @relation(fields: [tournamentId], references: [id], onDelete: SetNull)
  players    MatchPlayer[] // this is not a relation, it just says that it has multiple players

  @@index([tournamentId])
  @@index([startedAt])
}

model MatchPlayer {
  matchId Int
  userId  Int
  score   Int          @default(0)
  result  MatchResult?

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([matchId, userId])
  @@index([userId])
}
